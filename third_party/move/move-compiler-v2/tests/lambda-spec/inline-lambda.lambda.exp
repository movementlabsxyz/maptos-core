// -- Model dump before bytecode pipeline
module 0x42::Test {
    private fun call_inline(y: u64) {
        {
          let z: u64 = Add<u64>(3, y);
          {
            let (x: u64): (u64) = Tuple(y);
            {
              let y: bool = {
                let (x: u64): (u64) = Tuple(x);
                Gt<u64>(x, 2)
              };
              {
                let z': bool = {
                  let (x: u64): (u64) = Tuple(x);
                  Gt<u64>(x, z)
                };
                {
                  let w: bool = {
                    let (x: u64): (u64) = Tuple(x);
                    loop {
                      if Gt<u64>(z, 0) {
                        {
                          let _x: u64 = Add<u64>(x, 1);
                          Tuple()
                        }
                      } else {
                        break
                      }
                    };
                    Gt<u64>(x, 5)
                  };
                  spec {
                    assert Eq<bool>(y, Gt(x, 2));
                    assert Eq<bool>(y, Test::$inline___lambda__1_inline_1_868__call_inline(x));
                    assert Eq<bool>(z', Test::$inline___lambda__1_inline_2_879__call_inline(z, x));
                    assert Eq<bool>(w, Test::$inline___lambda__1_inline_3_890__call_inline(z, x));
                  }
                  ;
                  y
                }
              }
            }
          };
          Tuple()
        }
    }
    public fun test_apply(a1: u64,a2: u64) {
        {
          let r1: bool = spec {
            assert true;
            assert Test::$inline___lambda__1_inline_1_267__test_apply(0);
          }
          ;
          true;
          spec {
            assert r1;
          }
          ;
          {
            let r2: bool = spec {
              assert true;
              assert Test::$inline___lambda__1_inline_1_356__test_apply($t0, $t1, 0);
            }
            ;
            Neq<u64>(0, Add<u64>(a1, a2));
            spec {
              assert Not(r2);
            }
            ;
            Tuple()
          }
        }
    }
    private fun __lambda__1_inline_1_868__call_inline(x: u64): bool {
        Gt<u64>(x, 2)
    }
    private fun __lambda__1_inline_2_879__call_inline(z: u64,x: u64): bool {
        Gt<u64>(x, z)
    }
    private fun __lambda__1_inline_3_890__call_inline(z: u64,x: u64): bool {
        loop {
          if Gt<u64>(z, 0) {
            {
              let _x: u64 = Add<u64>(x, 1);
              Tuple()
            }
          } else {
            break
          }
        };
        Gt<u64>(x, 5)
    }
    private fun __lambda__1_inline_1_267__test_apply(v: u64): bool {
        Ge<u64>(v, 0)
    }
    private fun __lambda__1_inline_1_356__test_apply(a1: u64,a2: u64,v: u64): bool {
        Neq<u64>(v, Add<u64>(a1, a2))
    }
    spec fun $inline___lambda__1_inline_1_868__call_inline(x: u64): bool {
        Gt<u64>(x, 2)
    }
    spec fun $inline___lambda__1_inline_2_879__call_inline(z: u64,x: u64): bool {
        Gt<u64>(x, z)
    }
    spec fun $inline___lambda__1_inline_3_890__call_inline(z: u64,x: u64): bool;
    spec fun $inline___lambda__1_inline_1_267__test_apply(v: u64): bool {
        Ge<u64>(v, 0)
    }
    spec fun $inline___lambda__1_inline_1_356__test_apply(a1: u64,a2: u64,v: u64): bool {
        Neq<u64>(v, Add<u64>(a1, a2))
    }
} // end 0x42::Test

// -- Sourcified model before bytecode pipeline
module 0x42::Test {
    fun call_inline(y: u64) {
        let z = 3 + y;
        {
            let (x) = (y);
            let y = {
                let (x) = (x);
                x > 2
            };
            let z' = {
                let (x) = (x);
                x > z
            };
            let w = {
                let (x) = (x);
                while (z > 0) {
                    let _x = x + 1;
                };
                x > 5
            };

            /* spec {
              assert Eq<bool>(y, Gt(x, 2));
              assert Eq<bool>(y, Test::$inline___lambda__1_inline_1_868__call_inline(x));
              assert Eq<bool>(z', Test::$inline___lambda__1_inline_2_879__call_inline(z, x));
              assert Eq<bool>(w, Test::$inline___lambda__1_inline_3_890__call_inline(z, x));
            }
             */
            ;
            y
        };
    }
    public fun test_apply(a1: u64, a2: u64) {
        let r1 = {

            /* spec {
              assert true;
              assert Test::$inline___lambda__1_inline_1_267__test_apply(0);
            }
             */
            ;
            true
        };

        /* spec {
          assert r1;
        }
         */
        ;
        let r2 = {

            /* spec {
              assert true;
              assert Test::$inline___lambda__1_inline_1_356__test_apply($t0, $t1, 0);
            }
             */
            ;
            0 != a1 + a2
        };

        /* spec {
          assert Not(r2);
        }
         */
        ;
    }
    fun __lambda__1_inline_1_868__call_inline(x: u64): bool {
        x > 2
    }
    fun __lambda__1_inline_2_879__call_inline(z: u64, x: u64): bool {
        x > z
    }
    fun __lambda__1_inline_3_890__call_inline(z: u64, x: u64): bool {
        while (z > 0) {
            let _x = x + 1;
        };
        x > 5
    }
    fun __lambda__1_inline_1_267__test_apply(v: u64): bool {
        v >= 0
    }
    fun __lambda__1_inline_1_356__test_apply(a1: u64, a2: u64, v: u64): bool {
        v != a1 + a2
    }
}

============ initial bytecode ================

[variant baseline]
fun Test::call_inline($t0: u64) {
     var $t1: u64
     var $t2: u64
     var $t3: bool
     var $t4: u64
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: u64
     var $t9: bool
     var $t10: u64
     var $t11: u64
     var $t12: bool
     var $t13: u64
     var $t14: bool
     var $t15: u64
     var $t16: u64
     var $t17: u64
     var $t18: u64
     var $t19: u64
     var $t20: u64
     var $t21: u64
  0: $t2 := 3
  1: $t1 := +($t2, $t0)
  2: $t4 := infer($t0)
  3: $t6 := infer($t4)
  4: $t7 := infer($t6)
  5: $t8 := 2
  6: $t5 := >($t7, $t8)
  7: $t10 := infer($t4)
  8: $t11 := infer($t10)
  9: $t9 := >($t11, $t1)
 10: $t13 := infer($t4)
 11: label L0
 12: $t15 := infer($t1)
 13: $t16 := 0
 14: $t14 := >($t15, $t16)
 15: if ($t14) goto 16 else goto 21
 16: label L2
 17: $t18 := infer($t13)
 18: $t19 := 1
 19: $t17 := +($t18, $t19)
 20: goto 23
 21: label L3
 22: goto 25
 23: label L4
 24: goto 11
 25: label L1
 26: $t20 := infer($t13)
 27: $t21 := 5
 28: $t12 := >($t20, $t21)
 29: spec {
  assert Eq<bool>($t5, Gt($t4, 2));
  assert Eq<bool>($t5, Test::$inline___lambda__1_inline_1_868__call_inline($t4));
  assert Eq<bool>($t9, Test::$inline___lambda__1_inline_2_879__call_inline($t1, $t4));
  assert Eq<bool>($t12, Test::$inline___lambda__1_inline_3_890__call_inline($t1, $t4));
}

 30: $t3 := infer($t5)
 31: return ()
}


[variant baseline]
public fun Test::test_apply($t0: u64, $t1: u64) {
     var $t2: bool
     var $t3: bool
     var $t4: u64
     var $t5: u64
     var $t6: u64
  0: spec {
  assert true;
  assert Test::$inline___lambda__1_inline_1_267__test_apply(0);
}

  1: $t2 := true
  2: spec {
  assert $t2;
}

  3: spec {
  assert true;
  assert Test::$inline___lambda__1_inline_1_356__test_apply($t0, $t1, 0);
}

  4: $t4 := 0
  5: $t6 := infer($t0)
  6: $t5 := +($t6, $t1)
  7: $t3 := !=($t4, $t5)
  8: spec {
  assert Not($t3);
}

  9: return ()
}


[variant baseline]
fun Test::__lambda__1_inline_1_868__call_inline($t0: u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := >($t2, $t3)
  3: return $t1
}


[variant baseline]
fun Test::__lambda__1_inline_2_879__call_inline($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
  0: $t3 := infer($t1)
  1: $t2 := >($t3, $t0)
  2: return $t2
}


[variant baseline]
fun Test::__lambda__1_inline_3_890__call_inline($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: bool
     var $t4: u64
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: u64
  0: label L0
  1: $t4 := infer($t0)
  2: $t5 := 0
  3: $t3 := >($t4, $t5)
  4: if ($t3) goto 5 else goto 10
  5: label L2
  6: $t7 := infer($t1)
  7: $t8 := 1
  8: $t6 := +($t7, $t8)
  9: goto 12
 10: label L3
 11: goto 14
 12: label L4
 13: goto 0
 14: label L1
 15: $t9 := infer($t1)
 16: $t10 := 5
 17: $t2 := >($t9, $t10)
 18: return $t2
}


[variant baseline]
fun Test::__lambda__1_inline_1_267__test_apply($t0: u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 0
  2: $t1 := >=($t2, $t3)
  3: return $t1
}


[variant baseline]
fun Test::__lambda__1_inline_1_356__test_apply($t0: u64, $t1: u64, $t2: u64): bool {
     var $t3: bool
     var $t4: u64
     var $t5: u64
     var $t6: u64
  0: $t4 := infer($t2)
  1: $t6 := infer($t0)
  2: $t5 := +($t6, $t1)
  3: $t3 := !=($t4, $t5)
  4: return $t3
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun Test::call_inline($t0: u64) {
     var $t1: u64
     var $t2: u64
     var $t3: bool [unused]
     var $t4: u64
     var $t5: bool
     var $t6: u64 [unused]
     var $t7: u64 [unused]
     var $t8: u64 [unused]
     var $t9: bool
     var $t10: u64 [unused]
     var $t11: u64 [unused]
     var $t12: bool
     var $t13: u64 [unused]
     var $t14: bool
     var $t15: u64 [unused]
     var $t16: u64
     var $t17: u64 [unused]
     var $t18: u64 [unused]
     var $t19: u64 [unused]
     var $t20: u64 [unused]
     var $t21: u64 [unused]
     # live vars: $t0
  0: $t2 := 3
     # live vars: $t0, $t2
  1: $t1 := +($t2, $t0)
     # live vars: $t0, $t1
  2: $t4 := move($t0)
     # live vars: $t1, $t4
  3: $t0 := copy($t4)
     # live vars: $t0, $t1, $t4
  4: $t0 := move($t0)
     # live vars: $t0, $t1, $t4
  5: $t2 := 2
     # live vars: $t0, $t1, $t2, $t4
  6: $t5 := >($t0, $t2)
     # live vars: $t1, $t4, $t5
  7: $t0 := copy($t4)
     # live vars: $t0, $t1, $t4, $t5
  8: $t0 := move($t0)
     # live vars: $t0, $t1, $t4, $t5
  9: $t9 := >($t0, $t1)
     # live vars: $t1, $t4, $t5, $t9
 10: $t0 := copy($t4)
     # live vars: $t0, $t1, $t4, $t5, $t9
 11: label L0
     # live vars: $t0, $t1, $t4, $t5, $t9
 12: $t2 := copy($t1)
     # live vars: $t0, $t1, $t2, $t4, $t5, $t9
 13: $t16 := 0
     # live vars: $t0, $t1, $t2, $t4, $t5, $t9, $t16
 14: $t14 := >($t2, $t16)
     # live vars: $t0, $t1, $t4, $t5, $t9, $t14
 15: if ($t14) goto 16 else goto 21
     # live vars: $t0, $t1, $t4, $t5, $t9
 16: label L2
     # live vars: $t0, $t1, $t4, $t5, $t9
 17: $t2 := copy($t0)
     # live vars: $t0, $t1, $t2, $t4, $t5, $t9
 18: $t16 := 1
     # live vars: $t0, $t1, $t2, $t4, $t5, $t9, $t16
 19: $t2 := +($t2, $t16)
     # live vars: $t0, $t1, $t4, $t5, $t9
 20: goto 11
     # live vars: $t0, $t1, $t4, $t5, $t9
 21: label L3
     # live vars: $t0, $t1, $t4, $t5, $t9
 22: $t0 := move($t0)
     # live vars: $t0, $t1, $t4, $t5, $t9
 23: $t16 := 5
     # live vars: $t0, $t1, $t4, $t5, $t9, $t16
 24: $t12 := >($t0, $t16)
     # live vars: $t1, $t4, $t5, $t9, $t12
 25: spec {
  assert Eq<bool>($t5, Gt($t4, 2));
  assert Eq<bool>($t5, Test::$inline___lambda__1_inline_1_868__call_inline($t4));
  assert Eq<bool>($t9, Test::$inline___lambda__1_inline_2_879__call_inline($t1, $t4));
  assert Eq<bool>($t12, Test::$inline___lambda__1_inline_3_890__call_inline($t1, $t4));
}

     # live vars:
 26: return ()
}


[variant baseline]
public fun Test::test_apply($t0: u64, $t1: u64) {
     var $t2: bool
     var $t3: bool
     var $t4: u64
     var $t5: u64 [unused]
     var $t6: u64
     # live vars: $t0, $t1
  0: spec {
  assert true;
  assert Test::$inline___lambda__1_inline_1_267__test_apply(0);
}

     # live vars: $t0, $t1
  1: $t2 := true
     # live vars: $t0, $t1, $t2
  2: spec {
  assert $t2;
}

     # live vars: $t0, $t1
  3: spec {
  assert true;
  assert Test::$inline___lambda__1_inline_1_356__test_apply($t0, $t1, 0);
}

     # live vars: $t0, $t1
  4: $t4 := 0
     # live vars: $t0, $t1, $t4
  5: $t6 := move($t0)
     # live vars: $t1, $t4, $t6
  6: $t6 := +($t6, $t1)
     # live vars: $t4, $t6
  7: $t3 := !=($t4, $t6)
     # live vars: $t3
  8: spec {
  assert Not($t3);
}

     # live vars:
  9: return ()
}


[variant baseline]
fun Test::__lambda__1_inline_1_868__call_inline($t0: u64): bool {
     var $t1: bool
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 2
     # live vars: $t0, $t3
  2: $t1 := >($t0, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun Test::__lambda__1_inline_2_879__call_inline($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64 [unused]
     # live vars: $t0, $t1
  0: $t1 := move($t1)
     # live vars: $t0, $t1
  1: $t2 := >($t1, $t0)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
fun Test::__lambda__1_inline_3_890__call_inline($t0: u64, $t1: u64): bool {
     var $t2: bool [unused]
     var $t3: bool
     var $t4: u64
     var $t5: u64
     var $t6: u64 [unused]
     var $t7: u64 [unused]
     var $t8: u64 [unused]
     var $t9: u64 [unused]
     var $t10: u64 [unused]
     # live vars: $t0, $t1
  0: label L0
     # live vars: $t0, $t1
  1: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  2: $t5 := 0
     # live vars: $t0, $t1, $t4, $t5
  3: $t3 := >($t4, $t5)
     # live vars: $t0, $t1, $t3
  4: if ($t3) goto 5 else goto 10
     # live vars: $t0, $t1
  5: label L2
     # live vars: $t0, $t1
  6: $t4 := copy($t1)
     # live vars: $t0, $t1, $t4
  7: $t5 := 1
     # live vars: $t0, $t1, $t4, $t5
  8: $t4 := +($t4, $t5)
     # live vars: $t0, $t1
  9: goto 0
     # live vars: $t0, $t1
 10: label L3
     # live vars: $t1
 11: $t1 := move($t1)
     # live vars: $t1
 12: $t0 := 5
     # live vars: $t0, $t1
 13: $t3 := >($t1, $t0)
     # live vars: $t3
 14: return $t3
}


[variant baseline]
fun Test::__lambda__1_inline_1_267__test_apply($t0: u64): bool {
     var $t1: bool
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 0
     # live vars: $t0, $t3
  2: $t1 := >=($t0, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun Test::__lambda__1_inline_1_356__test_apply($t0: u64, $t1: u64, $t2: u64): bool {
     var $t3: bool
     var $t4: u64 [unused]
     var $t5: u64 [unused]
     var $t6: u64 [unused]
     # live vars: $t0, $t1, $t2
  0: $t2 := move($t2)
     # live vars: $t0, $t1, $t2
  1: $t0 := move($t0)
     # live vars: $t0, $t1, $t2
  2: $t0 := +($t0, $t1)
     # live vars: $t0, $t2
  3: $t3 := !=($t2, $t0)
     # live vars: $t3
  4: return $t3
}


============ disassembled file-format ==================
// Move bytecode v8
module 42.Test {


call_inline(y: u64) /* def_idx: 0 */ {
L1:	z: u64
L2:	x: u64
L3:	y: bool
L4:	z': bool
L5:	w: bool
B0:
	0: LdU64(3)
	1: CopyLoc[0](y: u64)
	2: Add
	3: StLoc[1](z: u64)
	4: MoveLoc[0](y: u64)
	5: StLoc[2](x: u64)
	6: CopyLoc[2](x: u64)
	7: LdU64(2)
	8: Gt
	9: StLoc[3](y: bool)
	10: CopyLoc[2](x: u64)
	11: CopyLoc[1](z: u64)
	12: Gt
	13: StLoc[4](z': bool)
	14: CopyLoc[2](x: u64)
	15: StLoc[0](y: u64)
B1:
	16: CopyLoc[1](z: u64)
	17: LdU64(0)
	18: Gt
	19: BrFalse(25)
B2:
	20: CopyLoc[0](y: u64)
	21: LdU64(1)
	22: Add
	23: Pop
	24: Branch(16)
B3:
	25: MoveLoc[0](y: u64)
	26: LdU64(5)
	27: Gt
	28: StLoc[5](w: bool)
	29: Nop
	30: Ret
}
public test_apply(a1: u64, a2: u64) /* def_idx: 1 */ {
L2:	r1: bool
L3:	r2: bool
B0:
	0: Nop
	1: LdTrue
	2: StLoc[2](r1: bool)
	3: Nop
	4: Nop
	5: LdU64(0)
	6: MoveLoc[0](a1: u64)
	7: MoveLoc[1](a2: u64)
	8: Add
	9: Neq
	10: StLoc[3](r2: bool)
	11: Nop
	12: Ret
}
__lambda__1_inline_1_868__call_inline(x: u64): bool /* def_idx: 2 */ {
B0:
	0: MoveLoc[0](x: u64)
	1: LdU64(2)
	2: Gt
	3: Ret
}
__lambda__1_inline_2_879__call_inline(z: u64, x: u64): bool /* def_idx: 3 */ {
B0:
	0: MoveLoc[1](x: u64)
	1: MoveLoc[0](z: u64)
	2: Gt
	3: Ret
}
__lambda__1_inline_3_890__call_inline(z: u64, x: u64): bool /* def_idx: 4 */ {
B0:
	0: CopyLoc[0](z: u64)
	1: LdU64(0)
	2: Gt
	3: BrFalse(9)
B1:
	4: CopyLoc[1](x: u64)
	5: LdU64(1)
	6: Add
	7: Pop
	8: Branch(0)
B2:
	9: MoveLoc[1](x: u64)
	10: LdU64(5)
	11: Gt
	12: Ret
}
__lambda__1_inline_1_267__test_apply(v: u64): bool /* def_idx: 5 */ {
B0:
	0: MoveLoc[0](v: u64)
	1: LdU64(0)
	2: Ge
	3: Ret
}
__lambda__1_inline_1_356__test_apply(a1: u64, a2: u64, v: u64): bool /* def_idx: 6 */ {
B0:
	0: MoveLoc[2](v: u64)
	1: MoveLoc[0](a1: u64)
	2: MoveLoc[1](a2: u64)
	3: Add
	4: Neq
	5: Ret
}
}
============ bytecode verification succeeded ========
