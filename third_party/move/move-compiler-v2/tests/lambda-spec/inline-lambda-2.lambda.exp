// -- Model dump before bytecode pipeline
module 0x42::m {
    use std::vector;
    struct T {
        issuer: vector<u8>,
        version: u64,
    }
    struct J {
        variant: u64,
    }
    struct S {
        entries: vector<T>,
    }
    private fun test(s: &mut S,issuer: vector<u8>) {
        {
          let x: u64 = vector::length<T>(Borrow(Immutable)(select m::S.entries<&mut S>(s)));
          {
            let (_found: bool, _index: u64): (bool, u64) = {
              let (v: &vector<T>): (&vector<T>) = Tuple(Borrow(Immutable)(select m::S.entries<&mut S>(s)));
              {
                let find: bool = false;
                {
                  let found_index: u64 = 0;
                  {
                    let i: u64 = 0;
                    {
                      let x': u64 = vector::length<T>(v);
                      {
                        let len: u64 = vector::length<T>(v);
                        loop {
                          if Lt<u64>(i, len) {
                            if {
                              let (obj: &T): (&T) = Tuple(vector::borrow<T>(v, i));
                              spec {
                                assume Gt(Len<u8>($t1), 0);
                              }
                              ;
                              And(Eq<vector<u8>>(select m::T.issuer<&T>(obj), issuer), Gt<u64>(x, 0))
                            } {
                              find: bool = true;
                              found_index: u64 = i;
                              break
                            } else {
                              Tuple()
                            };
                            i: u64 = Add<u64>(i, x');
                            Tuple()
                          } else {
                            break
                          }
                        };
                        spec {
                          assert Implies(find, m::$inline___lambda__1_inline_1_956__test($t1, x, Index(v, found_index)));
                        }
                        ;
                        Tuple(find, found_index)
                      }
                    }
                  }
                }
              }
            };
            Tuple()
          }
        }
    }
    private fun __lambda__1_inline_1_956__test(issuer: vector<u8>,x: u64,obj: &T): bool {
        spec {
          assume Gt(Len<u8>($t0), 0);
        }
        ;
        And(Eq<vector<u8>>(select m::T.issuer<&T>(obj), issuer), Gt<u64>(x, 0))
    }
    spec fun $inline___lambda__1_inline_1_956__test(issuer: vector<u8>,x: u64,obj: T): bool {
        And(Eq<vector<u8>>(select m::T.issuer<0x42::m::T>(obj), issuer), Gt<u64>(x, 0))
    }
} // end 0x42::m

// -- Sourcified model before bytecode pipeline
module 0x42::m {
    struct T has copy, drop, store {
        issuer: vector<u8>,
        version: u64,
    }
    struct J has copy, drop, store {
        variant: u64,
    }
    struct S has copy, drop, store {
        entries: vector<T>,
    }
    fun test(s: &mut S, issuer: vector<u8>) {
        let x = 0x1::vector::length<T>(&s.entries);
        let (_found,_index) = {
            let (v) = (&s.entries);
            let find = false;
            let found_index = 0;
            let i = 0;
            let x' = 0x1::vector::length<T>(v);
            let len = 0x1::vector::length<T>(v);
            while (i < len) {
                if ({
                    let (obj) = (0x1::vector::borrow<T>(v, i));

                    /* spec {
                      assume Gt(Len<u8>($t1), 0);
                    }
                     */
                    ;
                    obj.issuer == issuer && x > 0
                }) {
                    find = true;
                    found_index = i;
                    break
                };
                i = i + x';
            };

            /* spec {
              assert Implies(find, m::$inline___lambda__1_inline_1_956__test($t1, x, Index(v, found_index)));
            }
             */
            ;
            (find, found_index)
        };
    }
    fun __lambda__1_inline_1_956__test(issuer: vector<u8>, x: u64, obj: &T): bool {

        /* spec {
          assume Gt(Len<u8>($t0), 0);
        }
         */
        ;
        obj.issuer == issuer && x > 0
    }
}

============ initial bytecode ================

[variant baseline]
fun m::test($t0: &mut 0x42::m::S, $t1: vector<u8>) {
     var $t2: u64
     var $t3: &vector<0x42::m::T>
     var $t4: bool
     var $t5: u64
     var $t6: &vector<0x42::m::T>
     var $t7: &vector<0x42::m::T>
     var $t8: bool
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: u64
     var $t15: bool
     var $t16: &0x42::m::T
     var $t17: &0x42::m::T
     var $t18: &vector<0x42::m::T>
     var $t19: bool
     var $t20: vector<u8>
     var $t21: &vector<u8>
     var $t22: u64
     var $t23: u64
     var $t24: bool
     var $t25: u64
     var $t26: u64
  0: $t3 := borrow_field<0x42::m::S>.entries($t0)
  1: $t2 := vector::length<0x42::m::T>($t3)
  2: $t7 := borrow_field<0x42::m::S>.entries($t0)
  3: $t6 := infer($t7)
  4: $t8 := false
  5: $t9 := 0
  6: $t10 := 0
  7: $t11 := vector::length<0x42::m::T>($t6)
  8: $t12 := vector::length<0x42::m::T>($t6)
  9: label L0
 10: $t14 := infer($t10)
 11: $t13 := <($t14, $t12)
 12: if ($t13) goto 13 else goto 43
 13: label L2
 14: $t18 := infer($t6)
 15: $t17 := vector::borrow<0x42::m::T>($t18, $t10)
 16: $t16 := infer($t17)
 17: spec {
  assume Gt(Len<u8>($t1), 0);
}

 18: $t21 := borrow_field<0x42::m::T>.issuer($t16)
 19: $t20 := read_ref($t21)
 20: $t19 := ==($t20, $t1)
 21: if ($t19) goto 22 else goto 27
 22: label L5
 23: $t22 := infer($t2)
 24: $t23 := 0
 25: $t15 := >($t22, $t23)
 26: goto 29
 27: label L6
 28: $t15 := false
 29: label L7
 30: if ($t15) goto 31 else goto 37
 31: label L8
 32: $t24 := true
 33: $t8 := infer($t24)
 34: $t9 := infer($t10)
 35: goto 47
 36: goto 38
 37: label L9
 38: label L10
 39: $t26 := infer($t10)
 40: $t25 := +($t26, $t11)
 41: $t10 := infer($t25)
 42: goto 45
 43: label L3
 44: goto 47
 45: label L4
 46: goto 9
 47: label L1
 48: spec {
  assert Implies($t8, m::$inline___lambda__1_inline_1_956__test($t1, $t2, Index($t6, $t9)));
}

 49: $t4 := infer($t8)
 50: $t5 := infer($t9)
 51: return ()
}


[variant baseline]
fun m::__lambda__1_inline_1_956__test($t0: vector<u8>, $t1: u64, $t2: &0x42::m::T): bool {
     var $t3: bool
     var $t4: bool
     var $t5: vector<u8>
     var $t6: &vector<u8>
     var $t7: u64
     var $t8: u64
  0: spec {
  assume Gt(Len<u8>($t0), 0);
}

  1: $t6 := borrow_field<0x42::m::T>.issuer($t2)
  2: $t5 := read_ref($t6)
  3: $t4 := ==($t5, $t0)
  4: if ($t4) goto 5 else goto 10
  5: label L0
  6: $t7 := infer($t1)
  7: $t8 := 0
  8: $t3 := >($t7, $t8)
  9: goto 12
 10: label L1
 11: $t3 := false
 12: label L2
 13: return $t3
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun m::test($t0: &mut 0x42::m::S, $t1: vector<u8>) {
     var $t2: u64
     var $t3: &vector<0x42::m::T>
     var $t4: bool [unused]
     var $t5: u64 [unused]
     var $t6: &vector<0x42::m::T>
     var $t7: &vector<0x42::m::T> [unused]
     var $t8: bool
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: u64
     var $t15: bool [unused]
     var $t16: &0x42::m::T [unused]
     var $t17: &0x42::m::T
     var $t18: &vector<0x42::m::T> [unused]
     var $t19: bool [unused]
     var $t20: vector<u8>
     var $t21: &vector<u8>
     var $t22: u64 [unused]
     var $t23: u64
     var $t24: bool
     var $t25: u64 [unused]
     var $t26: u64 [unused]
     # live vars: $t0, $t1
  0: $t3 := borrow_field<0x42::m::S>.entries($t0)
     # live vars: $t0, $t1, $t3
  1: $t2 := vector::length<0x42::m::T>($t3)
     # live vars: $t0, $t1, $t2
  2: $t3 := borrow_field<0x42::m::S>.entries($t0)
     # live vars: $t1, $t2, $t3
  3: $t6 := move($t3)
     # live vars: $t1, $t2, $t6
  4: $t8 := false
     # live vars: $t1, $t2, $t6, $t8
  5: $t9 := 0
     # live vars: $t1, $t2, $t6, $t8, $t9
  6: $t10 := 0
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10
  7: $t11 := vector::length<0x42::m::T>($t6)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11
  8: $t12 := vector::length<0x42::m::T>($t6)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
  9: label L0
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 10: $t14 := copy($t10)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t14
 11: $t13 := <($t14, $t12)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t13
 12: if ($t13) goto 15 else goto 13
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 13: label L11
     # live vars: $t1, $t2, $t6, $t8, $t9
 14: goto 33
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 15: label L2
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 16: $t3 := copy($t6)
     # live vars: $t1, $t2, $t3, $t6, $t8, $t9, $t10, $t11, $t12
 17: $t17 := vector::borrow<0x42::m::T>($t3, $t10)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t17
 18: spec {
  assume Gt(Len<u8>($t1), 0);
}

     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t17
 19: $t21 := borrow_field<0x42::m::T>.issuer($t17)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t21
 20: $t20 := read_ref($t21)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t20
 21: $t13 := ==($t20, $t1)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t13
 22: if ($t13) goto 23 else goto 42
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 23: label L5
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 24: $t14 := copy($t2)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t14
 25: $t23 := 0
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t14, $t23
 26: $t13 := >($t14, $t23)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t13
 27: label L7
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t13
 28: if ($t13) goto 29 else goto 37
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 29: label L8
     # live vars: $t1, $t2, $t6, $t10
 30: $t24 := true
     # live vars: $t1, $t2, $t6, $t10, $t24
 31: $t8 := move($t24)
     # live vars: $t1, $t2, $t6, $t8, $t10
 32: $t9 := move($t10)
     # live vars: $t1, $t2, $t6, $t8, $t9
 33: label L1
     # live vars: $t1, $t2, $t6, $t8, $t9
 34: spec {
  assert Implies($t8, m::$inline___lambda__1_inline_1_956__test($t1, $t2, Index($t6, $t9)));
}

     # live vars: $t6
 35: drop($t6)
     # live vars:
 36: return ()
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 37: label L10
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 38: $t14 := move($t10)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t11, $t12, $t14
 39: $t14 := +($t14, $t11)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t11, $t12, $t14
 40: $t10 := move($t14)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 41: goto 9
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 42: label L6
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 43: $t13 := false
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t13
 44: goto 27
}


[variant baseline]
fun m::__lambda__1_inline_1_956__test($t0: vector<u8>, $t1: u64, $t2: &0x42::m::T): bool {
     var $t3: bool [unused]
     var $t4: bool
     var $t5: vector<u8>
     var $t6: &vector<u8>
     var $t7: u64
     var $t8: u64
     # live vars: $t0, $t1, $t2
  0: spec {
  assume Gt(Len<u8>($t0), 0);
}

     # live vars: $t0, $t1, $t2
  1: $t6 := borrow_field<0x42::m::T>.issuer($t2)
     # live vars: $t0, $t1, $t6
  2: $t5 := read_ref($t6)
     # live vars: $t0, $t1, $t5
  3: $t4 := ==($t5, $t0)
     # live vars: $t1, $t4
  4: if ($t4) goto 5 else goto 11
     # live vars: $t1
  5: label L0
     # live vars: $t1
  6: $t7 := move($t1)
     # live vars: $t7
  7: $t8 := 0
     # live vars: $t7, $t8
  8: $t4 := >($t7, $t8)
     # live vars: $t4
  9: label L2
     # live vars: $t4
 10: return $t4
     # live vars: $t1
 11: label L1
     # live vars:
 12: $t4 := false
     # live vars: $t4
 13: goto 9
}


============ disassembled file-format ==================
// Move bytecode v8
module 42.m {
struct T has copy, drop, store {
	issuer: vector<u8>,
	version: u64
}
struct J has copy, drop, store {
	variant: u64
}
struct S has copy, drop, store {
	entries: vector<T>
}

test(s: &mut S, issuer: vector<u8>) /* def_idx: 0 */ {
L2:	x: u64
L3:	v: &vector<T>
L4:	find: bool
L5:	found_index: u64
L6:	i: u64
L7:	x': u64
L8:	len: u64
L9:	$t13: bool
B0:
	0: CopyLoc[0](s: &mut S)
	1: ImmBorrowField[0](S.entries: vector<T>)
	2: VecLen(2)
	3: StLoc[2](x: u64)
	4: MoveLoc[0](s: &mut S)
	5: ImmBorrowField[0](S.entries: vector<T>)
	6: StLoc[3](v: &vector<T>)
	7: LdFalse
	8: StLoc[4](find: bool)
	9: LdU64(0)
	10: StLoc[5](found_index: u64)
	11: LdU64(0)
	12: StLoc[6](i: u64)
	13: CopyLoc[3](v: &vector<T>)
	14: VecLen(2)
	15: StLoc[7](x': u64)
	16: CopyLoc[3](v: &vector<T>)
	17: VecLen(2)
	18: StLoc[8](len: u64)
B1:
	19: CopyLoc[6](i: u64)
	20: CopyLoc[8](len: u64)
	21: Lt
	22: BrTrue(24)
B2:
	23: Branch(43)
B3:
	24: CopyLoc[3](v: &vector<T>)
	25: CopyLoc[6](i: u64)
	26: VecImmBorrow(2)
	27: Nop
	28: ImmBorrowField[1](T.issuer: vector<u8>)
	29: ReadRef
	30: CopyLoc[1](issuer: vector<u8>)
	31: Eq
	32: BrFalse(52)
B4:
	33: CopyLoc[2](x: u64)
	34: LdU64(0)
	35: Gt
	36: StLoc[9]($t13: bool)
B5:
	37: MoveLoc[9]($t13: bool)
	38: BrFalse(47)
B6:
	39: LdTrue
	40: StLoc[4](find: bool)
	41: MoveLoc[6](i: u64)
	42: StLoc[5](found_index: u64)
B7:
	43: Nop
	44: MoveLoc[3](v: &vector<T>)
	45: Pop
	46: Ret
B8:
	47: MoveLoc[6](i: u64)
	48: CopyLoc[7](x': u64)
	49: Add
	50: StLoc[6](i: u64)
	51: Branch(19)
B9:
	52: LdFalse
	53: StLoc[9]($t13: bool)
	54: Branch(37)
}
__lambda__1_inline_1_956__test(issuer: vector<u8>, x: u64, obj: &T): bool /* def_idx: 1 */ {
L3:	$t4: bool
B0:
	0: Nop
	1: MoveLoc[2](obj: &T)
	2: ImmBorrowField[1](T.issuer: vector<u8>)
	3: ReadRef
	4: MoveLoc[0](issuer: vector<u8>)
	5: Eq
	6: BrFalse(13)
B1:
	7: MoveLoc[1](x: u64)
	8: LdU64(0)
	9: Gt
	10: StLoc[3]($t4: bool)
B2:
	11: MoveLoc[3]($t4: bool)
	12: Ret
B3:
	13: LdFalse
	14: StLoc[3]($t4: bool)
	15: Branch(11)
}
}
============ bytecode verification succeeded ========
